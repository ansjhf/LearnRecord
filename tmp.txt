import org.apache.poi.openxml4j.opc.OPCPackage;
import org.apache.poi.xssf.eventusermodel.XSSFReader;
import org.apache.poi.xssf.model.SharedStringsTable;
import org.apache.poi.xssf.model.StylesTable;
import org.apache.poi.xssf.eventusermodel.XSSFSheetXMLHandler;
import org.apache.poi.xssf.eventusermodel.ReadOnlySharedStringsTable;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import java.io.InputStream;
import java.util.Iterator;

public class ExcelReader {

    public void process(String filePath) throws Exception {
        try (OPCPackage pkg = OPCPackage.open(filePath)) {
            XSSFReader reader = new XSSFReader(pkg);

            // 获取 sharedStrings 和样式表
            SharedStringsTable sst = new ReadOnlySharedStringsTable(pkg);
            StylesTable styles = reader.getStylesTable();

            // 只处理第一个 sheet
            Iterator<InputStream> sheets = reader.getSheetsData();
            if (!sheets.hasNext()) {
                System.out.println("没有找到 Sheet");
                return;
            }

            try (InputStream sheetStream = sheets.next()) {
                XMLReader parser = XMLReaderFactory.createXMLReader();

                SheetHandler handler = new SheetHandler(); // 独立类
                XSSFSheetXMLHandler sheetHandler = new XSSFSheetXMLHandler(styles, null, sst, handler, null, false);
                parser.setContentHandler(sheetHandler);

                parser.parse(new InputSource(sheetStream));
            }
        }
    }

    public static void main(String[] args) throws Exception {
        new ExcelReader().process("your-file.xlsx");
    }
}


import org.apache.poi.xssf.usermodel.XSSFComment;
import org.apache.poi.xssf.eventusermodel.XSSFSheetXMLHandler.SheetContentsHandler;

import java.util.ArrayList;
import java.util.List;

public class SheetHandler implements SheetContentsHandler {

    private List<String> currentRow;
    private final List<String> headers = new ArrayList<>();
    private final List<List<String>> buffer = new ArrayList<>();
    private static final int BATCH_SIZE = 1000;

    private int rowIndex = 0;

    @Override
    public void startRow(int rowNum) {
        currentRow = new ArrayList<>();
        this.rowIndex = rowNum;
    }

    @Override
    public void cell(String cellReference, String formattedValue, XSSFComment comment) {
        currentRow.add(formattedValue != null ? formattedValue : "");
    }

    @Override
    public void endRow(int rowNum) {
        if (rowNum == 0) {
            headers.addAll(currentRow);
            System.out.println("表头字段：" + headers);
        } else {
            buffer.add(new ArrayList<>(currentRow));

            if (buffer.size() >= BATCH_SIZE) {
                handleBatch(buffer);
                buffer.clear();
            }
        }
    }

    @Override
    public void endSheet() {
        if (!buffer.isEmpty()) {
            handleBatch(buffer);
        }
    }

    private void handleBatch(List<List<String>> batch) {
        System.out.println("处理数据批次，行数: " + batch.size());
        // 你可以在这里调用写入数据库的逻辑
    }
}


@Override
public void cell(String cellReference, String formattedValue, XSSFComment comment) {
    String value = formattedValue != null ? formattedValue : "";
    System.out.println("读取单元格 " + cellReference + " -> " + value);
    currentRow.add(value);
}


@Override
public void endRow(int rowNum) {
    System.out.println("完成行：" + rowNum + " 数据：" + currentRow);

    if (rowNum == 0) {
        headers.addAll(currentRow);
        System.out.println("表头字段：" + headers);
    } else {
        buffer.add(new ArrayList<>(currentRow));
        if (buffer.size() >= BATCH_SIZE) {
            handleBatch(buffer);
            buffer.clear();
        }
    }
}

try (InputStream sheetStream = sheets.next()) {
    XMLReader parser = XMLReaderFactory.createXMLReader();

    SheetHandler handler = new SheetHandler(); // 独立类
    XSSFSheetXMLHandler sheetHandler = new XSSFSheetXMLHandler(styles, null, sst, handler, null, false);
    parser.setContentHandler(sheetHandler);

    try {
        parser.parse(new InputSource(sheetStream));
    } catch (Exception e) {
        System.err.println("SAX解析过程中出错！");
        e.printStackTrace(); // 请贴这里打印的异常行号
    }
}





